// In a module, we can define Struct, Resource and Procedure.
// Like a smart contract in Ethereum.
// Modules can be imported either with address + module name or from same file with module name
// e.g import 0x0.LibraCoin or import Transaction.LibraCoin
modules:
module BuildCastle {
    // possible types: resource, struct
}

module Math {
    // params: base x and the exponent n of type u64, returns result of opeartion as u64
    public pow(x: u64, n: u64) : u64 {
        if (copy(n) == 0) { // this ends recursion since something to the power of 0 is always 1
        return 1;
        }
        if (copy(n) == 1) { // this moves ownership over the value x to calling function when recursion ends
        return move(x);
        }
        if (copy(n) % 2 == 0) { // for even numbers do this
            return Self.pow(copy(x) * copy(x), copy(n) / 2);
        } else { // for odd numbers do that
            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);
        }
    }
}

script:
import Transaction.BuildCastle;
import Transaction.Math;
// a one-time execution piece of code goes into the transaction script with main() as its entry point
// main() is a special kind of procedure.
// Procedures need to end with a return statement.
// Ordinary procedures are put into modules, imported in the script section and called from within main().
main() {
    // bindings (of ownership) always first or compiler throws
    // possible types: bool, address, bytearray, u64
    let SerialDigits: u64;
    let SerialLimit: u64;

    // initialization
    SerialDigits = 8;
    SerialLimit = Math.pow(10, copy(SerialDigits)); // with copy the value of an identifier is able to equal to that of another identifier without transferring the ownership
    return;
}